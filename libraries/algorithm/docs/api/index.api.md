## API Report File for "@hz-9/algorithm"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Edge as Edge_2 } from './graph';
import { Graph as Graph_2 } from './graph';
import { IGraphShortestPathReturn as IGraphShortestPathReturn_2 } from './_.shortest-path';
import { SearchCallback as SearchCallback_2 } from '../types';
import { Vertice as Vertice_2 } from './graph';

// @public
export class AdelsonVelskiiLandiTree<T> extends BinarySearchTree<T> {
    // Warning: (ae-forgotten-export) The symbol "TreeNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _addNode(node: TreeNode<T> | undefined, value: T): TreeNode<T>;
    // Warning: (ae-forgotten-export) The symbol "BalanceFactor" needs to be exported by the entry point index.d.ts
    protected _getBalanceFactor(node: TreeNode<T>): BalanceFactor;
    protected _getNodeHeight(node: TreeNode<T> | undefined): number;
    // (undocumented)
    protected _removeNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
    protected _rotationLL(node: TreeNode<T>): TreeNode<T>;
    protected _rotationLR(node: TreeNode<T>): TreeNode<T>;
    protected _rotationRL(node: TreeNode<T>): TreeNode<T>;
    protected _rotationRR(node: TreeNode<T>): TreeNode<T>;
}

// Warning: (ae-forgotten-export) The symbol "Deque" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayDeque<T> extends ArrayQueue<T> implements Deque<T> {
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// Warning: (ae-forgotten-export) The symbol "Queue" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    protected _list: Array<T>;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// Warning: (ae-forgotten-export) The symbol "Stack" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class BetterHashmap<K, V> extends SquareProbingHashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
}

// Warning: (ae-forgotten-export) The symbol "Tree" needs to be exported by the entry point index.d.ts
//
// @public
export class BinarySearchTree<T> extends Tree<T> {
    // (undocumented)
    protected _addNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
    // (undocumented)
    protected _hasNode(node: TreeNode<T> | undefined, value: T): boolean;
    // Warning: (ae-forgotten-export) The symbol "OrderTraverseCallback" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _inOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _maxNode(node: TreeNode<T> | undefined): TreeNode<T> | undefined;
    // (undocumented)
    protected _minNode(node: TreeNode<T> | undefined): TreeNode<T> | undefined;
    // (undocumented)
    protected _postOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _preOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _removeNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
}

// Warning: (ae-forgotten-export) The symbol "SearchCallback" needs to be exported by the entry point index.d.ts
//
// @public
export const breadthFirstSearch: <T>(graph: Graph<T>, startVertex: T | Vertice<T>, callback: SearchCallback<T, Edge<Vertice<T>>>) => void;

// @public
export const breadthFirstSearchShortestPath: <T>(graph: Graph<T>, startVertex: T | Vertice<T>) => IGraphShortestPathReturn<T>;

// @public
export const breadthFirstSearchShortestPathString: <T>(graph: Graph<T>, startVertex: T | Vertice<T>, chars?: string) => string;

// @public
export const defaultCompare: <T>(a: T, b: T) => number;

// @public
export const defaultEquals: <T>(a?: T | undefined, b?: T | undefined) => boolean;

// @public
export const depthFirstSearch: <T>(graph: Graph<T>, startVertex: T | Vertice<T>, callback: SearchCallback<T, Edge<Vertice<T>>>, explore?: SearchCallback<T, Edge<Vertice<T>>>) => void;

// @public
export const depthFirstSearchShortestPath: <T>(graph: Graph<T>, startVertex: T | Vertice<T>) => IGraphShortestPathReturn<T>;

// @public
export const depthFirstSearchShortestPathString: <T>(graph: Graph<T>, startVertex: T | Vertice<T>, chars?: string) => string;

// @public
export const depthFirstSearchVariety: <T>(graph: Graph<T>, startVertex: T | Vertice<T>, callback: SearchCallback<T, Edge<Vertice<T>>>) => void;

// @public
export const djb2HashCode: ToHashCode;

// Warning: (ae-forgotten-export) The symbol "LinkedList" needs to be exported by the entry point index.d.ts
//
// @public
export class DoublyLinkedList<T> extends LinkedList<T, DoublyLinkedListNode<T>> {
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    popNode(): DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    remove(value: T): boolean;
    // (undocumented)
    removeAt(index: number): boolean;
    // (undocumented)
    shiftNode(): DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    unshift(value: T): boolean;
}

// Warning: (ae-forgotten-export) The symbol "LinkedListNode" needs to be exported by the entry point index.d.ts
//
// @public
export class DoublyLinkedListNode<T> extends LinkedListNode<T> {
    constructor(val: T);
    // (undocumented)
    next: DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    prev: DoublyLinkedListNode<T> | undefined;
}

// @public
export class Edge<V> {
    constructor(from: V, to: V, weight: number);
    // (undocumented)
    readonly from: V;
    // (undocumented)
    readonly to: V;
    // (undocumented)
    weight: number;
}

// @public
export const EMPTY_KEY_VALUE: KeyValue<unknown, unknown>;

// Warning: (ae-forgotten-export) The symbol "Base" needs to be exported by the entry point index.d.ts
//
// @public
export class Graph<T> implements Base<IGraphToArrayItem<T>> {
    constructor(isDirected?: boolean, equalsFn?: typeof defaultEquals<T>);
    addEdge(fromVertex: T | Vertice<T>, toVertex: T | Vertice<T>, weight?: number): void;
    addVertex(vertex: T | Vertice<T>): Vertice<T>;
    readonly adjList: Map<Vertice<T>, Array<Edge<Vertice<T>>>>;
    // (undocumented)
    clear(): void;
    protected readonly _equalsFn: (a?: T, b?: T) => boolean;
    getVertex(vertex: T | Vertice<T>): Vertice<T> | undefined;
    hasEdge(fromVertex: T | Vertice<T>, toVertex: T | Vertice<T>): boolean;
    hasVertex(vertex: T | Vertice<T>): boolean;
    readonly isDirected: boolean;
    // (undocumented)
    get isEmpty(): boolean;
    removeEdge(fromVertex: T | Vertice<T>, toVertex: T | Vertice<T>): boolean;
    removeVertex(vertex: T | Vertice<T>): boolean;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): IGraphToArrayItem<T>[];
    // (undocumented)
    toString(): string;
    readonly vertices: Array<Vertice<T>>;
}

// @public
export const GraphShortestPath: {
    readonly breadthFirstSearchShortestPath: <T>(graph: Graph_2<T>, startVertex: T | Vertice_2<T>) => IGraphShortestPathReturn_2<T>;
    readonly breadthFirstSearchShortestPathString: <T_1>(graph: Graph_2<T_1>, startVertex: T_1 | Vertice_2<T_1>, chars?: string) => string;
    readonly depthFirstSearchShortestPath: <T_2>(graph: Graph_2<T_2>, startVertex: T_2 | Vertice_2<T_2>) => IGraphShortestPathReturn_2<T_2>;
    readonly depthFirstSearchShortestPathString: <T_3>(graph: Graph_2<T_3>, startVertex: T_3 | Vertice_2<T_3>, chars?: string) => string;
};

// @public
export const GraphWalker: {
    readonly breadthFirstSearch: <T>(graph: Graph_2<T>, startVertex: T | Vertice_2<T>, callback: SearchCallback_2<T, Edge_2<Vertice_2<T>>>) => void;
    readonly depthFirstSearch: <T_1>(graph: Graph_2<T_1>, startVertex: T_1 | Vertice_2<T_1>, callback: SearchCallback_2<T_1, Edge_2<Vertice_2<T_1>>>, explore?: SearchCallback_2<T_1, Edge_2<Vertice_2<T_1>>>) => void;
    readonly depthFirstSearchVariety: <T_2>(graph: Graph_2<T_2>, startVertex: T_2 | Vertice_2<T_2>, callback: SearchCallback_2<T_2, Edge_2<Vertice_2<T_2>>>) => void;
};

// @public
export abstract class Hashmap<K, V> extends Base<IKeyValueObj<K, V>> {
    abstract get(key: K): V | undefined;
    abstract has(key: K): boolean;
    abstract remove(key: K): boolean;
    abstract set(key: K, value: V): boolean;
}

// @public (undocumented)
export interface IGraphShortestPathReturn<T> {
    // (undocumented)
    distances: Map<Vertice<T>, number>;
    // (undocumented)
    prodecessors: Map<Vertice<T>, Vertice<T> | undefined>;
}

// @public
export interface IGraphToArrayItem<T> {
    // (undocumented)
    edges: Array<{
        vertice: T;
        weight: number;
    }>;
    // (undocumented)
    vertice: T;
}

// @public
export interface IKeyValueObj<K, V> {
    // (undocumented)
    key: K;
    // (undocumented)
    value: V;
}

// @public
export class KeyValue<K, V> {
    constructor(key: K, value: V);
    // (undocumented)
    readonly key: K;
    toString(): string;
    // (undocumented)
    readonly value: V;
}

// @public
export const kVEqualFn: <K, V>(a?: KeyValue<K, V> | undefined, b?: KeyValue<K, V> | undefined) => boolean;

// @public
export const kVToObj: <K, V>(keyValue: KeyValue<K, V>) => IKeyValueObj<K, V>;

// @public
export class LinearProbingHashmap<K, V> extends SimpleHashmap<K, V> {
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
}

// @public
export class LinkedListDeque<T> extends LinkedListQueue<T> implements Deque<T> {
    constructor();
    // (undocumented)
    protected _linkedList: DoublyLinkedList<T>;
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// @public
export class LinkedListHashmap<K, V> implements Hashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, SinglyLinkedList<KeyValue<K, V>>>;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): IKeyValueObj<K, V>[];
    // (undocumented)
    protected _toHashCode: ToHashCode;
    // (undocumented)
    protected _toKeyStr: ToKeyStr<K>;
    // (undocumented)
    toString(): string;
}

// @public
export class LinkedListQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    protected _linkedList: SinglyLinkedList<T>;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class LinkedListStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export const loseloseHashCode: ToHashCode;

// Warning: (ae-forgotten-export) The symbol "Heap" needs to be exported by the entry point index.d.ts
//
// @public
export class MaxHeap<T> extends Heap<T> {
    // (undocumented)
    siftDown(index: number): void;
    // (undocumented)
    siftUp(index: number): void;
}

// @public
export class MinHeap<T> extends Heap<T> {
    // (undocumented)
    siftDown(index: number): void;
    // (undocumented)
    siftUp(index: number): void;
}

// @public
export class ObjectDeque<T> extends ObjectQueue<T> implements Deque<T> {
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// @public
export class ObjectQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    protected _flag: number;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, T>;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class ObjectStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class RedBlackTree<T> extends BinarySearchTree<T> {
    // (undocumented)
    add(value: T): void;
    // (undocumented)
    protected _addNode(node: RedBlackTreeNode<T> | undefined, value: T): RedBlackTreeNode<T> | undefined;
    // (undocumented)
    protected _fixTreeNode(node: RedBlackTreeNode<T>): void;
    // (undocumented)
    protected _root?: RedBlackTreeNode<T>;
    // (undocumented)
    protected rotationLL(node: RedBlackTreeNode<T>): void;
    // (undocumented)
    protected rotationRR(node: RedBlackTreeNode<T>): void;
}

// @public
export class RedBlackTreeNode<T> extends TreeNode<T> {
    constructor(val: T, left?: RedBlackTreeNode<T>, right?: RedBlackTreeNode<T>);
    // Warning: (ae-forgotten-export) The symbol "Color" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    color: Color | undefined;
    // (undocumented)
    left: RedBlackTreeNode<T> | undefined;
    // (undocumented)
    parent: RedBlackTreeNode<T> | undefined;
    // (undocumented)
    right: RedBlackTreeNode<T> | undefined;
}

// @public
export class SetPlus<T> extends Set<T> {
    static difference<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
    static intersection<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
    static isSubsetOf<T>(setA: Set<T>, setB: Set<T>): boolean;
    toSet(): Set<T>;
    static union<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
}

// @public
export class SimpleHashmap<K, V> implements Hashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, KeyValue<K, V>>;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): IKeyValueObj<K, V>[];
    // (undocumented)
    protected _toHashCode: ToHashCode;
    // (undocumented)
    protected _toKeyStr: ToKeyStr<K>;
    // (undocumented)
    toString(): string;
}

// @public
export class SinglyLinkedList<T> extends LinkedList<T, SinglyLinkedListNode<T>> {
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    popNode(): SinglyLinkedListNode<T> | undefined;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    remove(value: T): boolean;
    // (undocumented)
    removeAt(index: number): boolean;
    // (undocumented)
    shiftNode(): SinglyLinkedListNode<T> | undefined;
    // (undocumented)
    unshift(value: T): boolean;
}

// @public
export class SinglyLinkedListNode<T> extends LinkedListNode<T> {
}

// @public
export class SortedLinkedList<T> extends DoublyLinkedList<T> {
    constructor(equalsFn?: typeof defaultEquals<T>, compareFn?: typeof defaultCompare<T>);
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    protected readonly _compareFn: (a: T, b: T) => number;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    unshift(value: T): boolean;
}

// @public
export class SquareProbingHashmap<K, V> extends SimpleHashmap<K, V> {
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
}

// @public
export type ToHashCode = (keyStr: string) => number;

// @public
export type ToKeyStr<K> = (key: K) => string;

// @public
export const toKeyStrDefault: <K>(key: K) => string;

// @public
export class Vertice<T> {
    constructor(vertice: T);
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly vertice: T;
}

// (No @packageDocumentation comment for this package)

```
