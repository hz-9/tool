## API Report File for "@hz-9/algorithm"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class AdelsonVelskiiLandiTree<T> extends BinarySearchTree<T> {
    // Warning: (ae-forgotten-export) The symbol "TreeNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _addNode(node: TreeNode<T> | undefined, value: T): TreeNode<T>;
    // Warning: (ae-forgotten-export) The symbol "BalanceFactor" needs to be exported by the entry point index.d.ts
    protected _getBalanceFactor(node: TreeNode<T>): BalanceFactor;
    protected _getNodeHeight(node: TreeNode<T> | undefined): number;
    // (undocumented)
    protected _removeNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
    protected _rotationLL(node: TreeNode<T>): TreeNode<T>;
    protected _rotationLR(node: TreeNode<T>): TreeNode<T>;
    protected _rotationRL(node: TreeNode<T>): TreeNode<T>;
    protected _rotationRR(node: TreeNode<T>): TreeNode<T>;
}

// Warning: (ae-forgotten-export) The symbol "Deque" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayDeque<T> extends ArrayQueue<T> implements Deque<T> {
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// Warning: (ae-forgotten-export) The symbol "Queue" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    protected _list: Array<T>;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// Warning: (ae-forgotten-export) The symbol "Stack" needs to be exported by the entry point index.d.ts
//
// @public
export class ArrayStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class BetterHashmap<K, V> extends SquareProbingHashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
}

// Warning: (ae-forgotten-export) The symbol "Tree" needs to be exported by the entry point index.d.ts
//
// @public
export class BinarySearchTree<T> extends Tree<T> {
    // (undocumented)
    protected _addNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
    // (undocumented)
    protected _hasNode(node: TreeNode<T> | undefined, value: T): boolean;
    // Warning: (ae-forgotten-export) The symbol "OrderTraverseCallback" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _inOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _maxNode(node: TreeNode<T> | undefined): TreeNode<T> | undefined;
    // (undocumented)
    protected _minNode(node: TreeNode<T> | undefined): TreeNode<T> | undefined;
    // (undocumented)
    protected _postOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _preOrderTraverseNode(node: TreeNode<T> | undefined, callback: OrderTraverseCallback<T>): void;
    // (undocumented)
    protected _removeNode(node: TreeNode<T> | undefined, value: T): TreeNode<T> | undefined;
}

// @public
export const defaultCompare: <T>(a: T, b: T) => number;

// @public
export const defaultEquals: <T>(a?: T | undefined, b?: T | undefined) => boolean;

// @public
export const djb2HashCode: ToHashCode;

// Warning: (ae-forgotten-export) The symbol "LinkedList" needs to be exported by the entry point index.d.ts
//
// @public
export class DoublyLinkedList<T> extends LinkedList<T, DoublyLinkedListNode<T>> {
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    popNode(): DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    remove(value: T): boolean;
    // (undocumented)
    removeAt(index: number): boolean;
    // (undocumented)
    shiftNode(): DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    unshift(value: T): boolean;
}

// Warning: (ae-forgotten-export) The symbol "LinkedListNode" needs to be exported by the entry point index.d.ts
//
// @public
export class DoublyLinkedListNode<T> extends LinkedListNode<T> {
    constructor(val: T);
    // (undocumented)
    next: DoublyLinkedListNode<T> | undefined;
    // (undocumented)
    prev: DoublyLinkedListNode<T> | undefined;
}

// @public
export const EMPTY_KEY_VALUE: KeyValue<unknown, unknown>;

// Warning: (ae-forgotten-export) The symbol "Base" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Hashmap<K, V> extends Base<IKeyValueObj<K, V>> {
    abstract get(key: K): V | undefined;
    abstract has(key: K): boolean;
    abstract remove(key: K): boolean;
    abstract set(key: K, value: V): boolean;
}

// @public
export interface IKeyValueObj<K, V> {
    // (undocumented)
    key: K;
    // (undocumented)
    value: V;
}

// @public
export class KeyValue<K, V> {
    constructor(key: K, value: V);
    // (undocumented)
    readonly key: K;
    toString(): string;
    // (undocumented)
    readonly value: V;
}

// @public
export const kVEqualFn: <K, V>(a?: KeyValue<K, V> | undefined, b?: KeyValue<K, V> | undefined) => boolean;

// @public
export const kVToObj: <K, V>(keyValue: KeyValue<K, V>) => IKeyValueObj<K, V>;

// @public
export class LinearProbingHashmap<K, V> extends SimpleHashmap<K, V> {
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
}

// @public
export class LinkedListDeque<T> extends LinkedListQueue<T> implements Deque<T> {
    constructor();
    // (undocumented)
    protected _linkedList: DoublyLinkedList<T>;
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// @public
export class LinkedListHashmap<K, V> implements Hashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, SinglyLinkedList<KeyValue<K, V>>>;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): IKeyValueObj<K, V>[];
    // (undocumented)
    protected _toHashCode: ToHashCode;
    // (undocumented)
    protected _toKeyStr: ToKeyStr<K>;
    // (undocumented)
    toString(): string;
}

// @public
export class LinkedListQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    protected _linkedList: SinglyLinkedList<T>;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class LinkedListStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export const loseloseHashCode: ToHashCode;

// Warning: (ae-forgotten-export) The symbol "Heap" needs to be exported by the entry point index.d.ts
//
// @public
export class MaxHeap<T> extends Heap<T> {
    // (undocumented)
    siftDown(index: number): void;
    // (undocumented)
    siftUp(index: number): void;
}

// @public
export class MinHeap<T> extends Heap<T> {
    // (undocumented)
    siftDown(index: number): void;
    // (undocumented)
    siftUp(index: number): void;
}

// @public
export class ObjectDeque<T> extends ObjectQueue<T> implements Deque<T> {
    // (undocumented)
    peekBack(): T | undefined;
    // (undocumented)
    peekFront(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    unshift(value: T): void;
}

// @public
export class ObjectQueue<T> implements Queue<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get first(): T | undefined;
    protected _flag: number;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, T>;
    // (undocumented)
    get last(): T | undefined;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    push(value: T): void;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class ObjectStack<T> implements Stack<T> {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    peek(): T | undefined;
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(val: T): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export class SetPlus<T> extends Set<T> {
    static difference<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
    static intersection<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
    static isSubsetOf<T>(setA: Set<T>, setB: Set<T>): boolean;
    toSet(): Set<T>;
    static union<T>(setA: Set<T>, setB: Set<T>): SetPlus<T>;
}

// @public
export class SimpleHashmap<K, V> implements Hashmap<K, V> {
    constructor(toKeyStr?: ToKeyStr<K>, toHashCode?: ToHashCode);
    // (undocumented)
    clear(): void;
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected _items: Record<number, KeyValue<K, V>>;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
    // (undocumented)
    get size(): number;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    toArray(): IKeyValueObj<K, V>[];
    // (undocumented)
    protected _toHashCode: ToHashCode;
    // (undocumented)
    protected _toKeyStr: ToKeyStr<K>;
    // (undocumented)
    toString(): string;
}

// @public
export class SinglyLinkedList<T> extends LinkedList<T, SinglyLinkedListNode<T>> {
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    popNode(): SinglyLinkedListNode<T> | undefined;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    remove(value: T): boolean;
    // (undocumented)
    removeAt(index: number): boolean;
    // (undocumented)
    shiftNode(): SinglyLinkedListNode<T> | undefined;
    // (undocumented)
    unshift(value: T): boolean;
}

// @public
export class SinglyLinkedListNode<T> extends LinkedListNode<T> {
}

// @public
export class SortedLinkedList<T> extends DoublyLinkedList<T> {
    constructor(equalsFn?: typeof defaultEquals<T>, compareFn?: typeof defaultCompare<T>);
    // (undocumented)
    addAt(index: number, value: T): boolean;
    // (undocumented)
    protected readonly _compareFn: (a: T, b: T) => number;
    // (undocumented)
    push(value: T): boolean;
    // (undocumented)
    unshift(value: T): boolean;
}

// @public
export class SquareProbingHashmap<K, V> extends SimpleHashmap<K, V> {
    // (undocumented)
    get(key: K): V | undefined;
    // (undocumented)
    remove(key: K): boolean;
    // (undocumented)
    set(key: K, value: V): boolean;
}

// @public
export type ToHashCode = (keyStr: string) => number;

// @public
export type ToKeyStr<K> = (key: K) => string;

// @public
export const toKeyStrDefault: <K>(key: K) => string;

// (No @packageDocumentation comment for this package)

```
